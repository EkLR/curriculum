{"ts":1349752157513,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1349752160654,"patch":[[{"diffs":[[1,"/*!\n * reveal.js 2.1 r29\n * http://lab.hakim.se/reveal-js\n * MIT licensed\n * \n * Copyright (C) 2011-2012 Hakim El Hattab, http://hakim.se\n */\nvar Reveal = (function(){\n\n    'use strict';\n\t\n\tvar HORIZONTAL_SLIDES_SELECTOR = '.reveal .slides>section',\n\t\tVERTICAL_SLIDES_SELECTOR = '.reveal .slides>section.present>section',\n\n\t\t// Configurations defaults, can be overridden at initialization time \n\t\tconfig = {\n\t\t\t// Display controls in the bottom right corner\n\t\t\tcontrols: true,\n\n\t\t\t// Display a presentation progress bar\n\t\t\tprogress: true,\n\n\t\t\t// Push each slide change to the browser history\n\t\t\thistory: false,\n\n\t\t\t// Enable keyboard shortcuts for navigation\n\t\t\tkeyboard: true,\n\n\t\t\t// Enable the slide overview mode\n\t\t\toverview: true,\n\n\t\t\t// Loop the presentation\n\t\t\tloop: false,\n\n\t\t\t// Number of milliseconds between automatically proceeding to the \n\t\t\t// next slide, disabled when set to 0\n\t\t\tautoSlide: 0,\n\n\t\t\t// Enable slide navigation via mouse wheel\n\t\t\tmouseWheel: true,\n\n\t\t\t// Apply a 3D roll to links on hover\n\t\t\trollingLinks: true,\n\n\t\t\t// Transition style (see /css/theme)\n\t\t\ttheme: 'default', \n\n\t\t\t// Transition style\n\t\t\ttransition: 'default', // default/cube/page/concave/linear(2d),\n\n\t\t\t// Script dependencies to load\n\t\t\tdependencies: []\n\t\t},\n\n\t\t// The horizontal and verical index of the currently active slide\n\t\tindexh = 0,\n\t\tindexv = 0,\n\n\t\t// The previous and current slide HTML elements\n\t\tpreviousSlide,\n\t\tcurrentSlide,\n\n\t\t// Slides may hold a data-state attribute which we pick up and apply \n\t\t// as a class to the body. This list contains the combined state of \n\t\t// all current slides.\n\t\tstate = [],\n\n\t\t// Cached references to DOM elements\n\t\tdom = {},\n\n\t\t// Detect support for CSS 3D transforms\n\t\tsupports3DTransforms =  'WebkitPerspective' in document.body.style ||\n\t\t\t\t\t\t\t\t'MozPerspective' in document.body.style ||\n\t\t\t\t\t\t\t\t'msPerspective' in document.body.style ||\n\t\t\t\t\t\t\t\t'OPerspective' in document.body.style ||\n\t\t\t\t\t\t\t\t'perspective' in document.body.style,\n\t\t\n\t\tsupports2DTransforms =  'WebkitTransform' in document.body.style ||\n\t\t\t\t\t\t\t\t'MozTransform' in document.body.style ||\n\t\t\t\t\t\t\t\t'msTransform' in document.body.style ||\n\t\t\t\t\t\t\t\t'OTransform' in document.body.style ||\n\t\t\t\t\t\t\t\t'transform' in document.body.style,\n\t\t\n\t\t// Throttles mouse wheel navigation\n\t\tmouseWheelTimeout = 0,\n\n\t\t// An interval used to automatically move on to the next slide\n\t\tautoSlideTimeout = 0,\n\n\t\t// Delays updates to the URL due to a Chrome thumbnailer bug\n\t\twriteURLTimeout = 0,\n\n\t\t// Holds information about the currently ongoing touch input\n\t\ttouch = {\n\t\t\tstartX: 0,\n\t\t\tstartY: 0,\n\t\t\tstartSpan: 0,\n\t\t\tstartCount: 0,\n\t\t\thandled: false,\n\t\t\tthreshold: 40\n\t\t};\n\t\n\t\n\t/**\n\t * Starts up the presentation if the client is capable.\n\t */\n\tfunction initialize( options ) {\n\t\tif( ( !supports2DTransforms && !supports3DTransforms ) ) {\n\t\t\tdocument.body.setAttribute( 'class', 'no-transforms' );\n\n\t\t\t// If the browser doesn't support core features we won't be \n\t\t\t// using JavaScript to control the presentation\n\t\t\treturn;\n\t\t}\n\n\t\t// Copy options over to our config object\n\t\textend( config, options );\n\n\t\t// Make sure we've got all the DOM elements we need\n\t\tsetupDOM();\n\n\t\t// Hide the address bar in mobile browsers\n\t\thideAddressBar();\n\n\t\t// Loads the dependencies and continues to #start() once done\n\t\tload();\n\t\t\n\t}\n\n\t/**\n\t * Finds and stores references to DOM elements which are \n\t * required by the presentation. If a required element is \n\t * not found, it is created.\n\t */\n\tfunction setupDOM() {\n\t\t// Cache references to key DOM elements\n\t\tdom.theme = document.querySelector( '#theme' );\n\t\tdom.wrapper = document.querySelector( '.reveal' );\n\n\t\t// Progress bar\n\t\tif( !dom.wrapper.querySelector( '.progress' ) && config.progress ) {\n\t\t\tvar progressElement = document.createElement( 'div' );\n\t\t\tprogressElement.classList.add( 'progress' );\n\t\t\tprogressElement.innerHTML = '<span></span>';\n\t\t\tdom.wrapper.appendChild( progressElement );\n\t\t}\n\n\t\t// Arrow controls\n\t\tif( !dom.wrapper.querySelector( '.controls' ) && config.controls ) {\n\t\t\tvar controlsElement = document.createElement( 'aside' );\n\t\t\tcontrolsElement.classList.add( 'controls' );\n\t\t\tcontrolsElement.innerHTML = '<a class=\"left\" href=\"#\">&#x25C4;</a>' +\n\t\t\t\t\t\t\t\t\t\t'<a class=\"right\" href=\"#\">&#x25BA;</a>' +\n\t\t\t\t\t\t\t\t\t\t'<a class=\"up\" href=\"#\">&#x25B2;</a>' +\n\t\t\t\t\t\t\t\t\t\t'<a class=\"down\" href=\"#\">&#x25BC;</a>';\n\t\t\tdom.wrapper.appendChild( controlsElement );\n\t\t}\n\n\t\t// Presentation background element\n\t\tif( !dom.wrapper.querySelector( '.state-background' ) ) {\n\t\t\tvar backgroundElement = document.createElement( 'div' );\n\t\t\tbackgroundElement.classList.add( 'state-background' );\n\t\t\tdom.wrapper.appendChild( backgroundElement );\n\t\t}\n\n\t\t// Overlay graphic which is displayed during the paused mode\n\t\tif( !dom.wrapper.querySelector( '.pause-overlay' ) ) {\n\t\t\tvar pausedElement = document.createElement( 'div' );\n\t\t\tpausedElement.classList.add( 'pause-overlay' );\n\t\t\tdom.wrapper.appendChild( pausedElement );\n\t\t}\n\n\t\t// Cache references to elements\n\t\tdom.progress = document.querySelector( '.reveal .progress' );\n\t\tdom.progressbar = document.querySelector( '.reveal .progress span' );\n\n\t\tif ( config.controls ) {\n\t\t\tdom.controls = document.querySelector( '.reveal .controls' );\n\t\t\tdom.controlsLeft = document.querySelector( '.reveal .controls .left' );\n\t\t\tdom.controlsRight = document.querySelector( '.reveal .controls .right' );\n\t\t\tdom.controlsUp = document.querySelector( '.reveal .controls .up' );\n\t\t\tdom.controlsDown = document.querySelector( '.reveal .controls .down' );\n\t\t}\n\t}\n\n\t/**\n\t * Hides the address bar if we're on a mobile device.\n\t */\n\tfunction hideAddressBar() {\n\t\tif( navigator.userAgent.match( /(iphone|ipod|android)/i ) ) {\n\t\t\t// Give the page some scrollable overflow\n\t\t\tdocument.documentElement.style.overflow = 'scroll';\n\t\t\tdocument.body.style.height = '120%';\n\n\t\t\t// Events that should trigger the address bar to hide\n\t\t\twindow.addEventListener( 'load', removeAddressBar, false );\n\t\t\twindow.addEventListener( 'orientationchange', removeAddressBar, false );\n\t\t}\n\t}\n\n\t/**\n\t * Loads the dependencies of reveal.js. Dependencies are \n\t * defined via the configuration option 'dependencies' \n\t * and will be loaded prior to starting/binding reveal.js. \n\t * Some dependencies may have an 'async' flag, if so they \n\t * will load after reveal.js has been started up.\n\t */\n\tfunction load() {\n\t\tvar scripts = [],\n\t\t\tscriptsAsync = [];\n\n\t\tfor( var i = 0, len = config.dependencies.length; i < len; i++ ) {\n\t\t\tvar s = config.dependencies[i];\n\n\t\t\t// Load if there's no condition or the condition is truthy\n\t\t\tif( !s.condition || s.condition() ) {\n\t\t\t\tif( s.async ) {\n\t\t\t\t\tscriptsAsync.push( s.src );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscripts.push( s.src );\n\t\t\t\t}\n\n\t\t\t\t// Extension may contain callback functions\n\t\t\t\tif( typeof s.callback === 'function' ) {\n\t\t\t\t\thead.ready( s.src.match( /([\\w\\d_\\-]*)\\.?[^\\\\\\/]*$/i )[0], s.callback );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Called once synchronous scritps finish loading\n\t\tfunction proceed() {\n\t\t\t// Load asynchronous scripts\n\t\t\thead.js.apply( null, scriptsAsync );\n\t\t\t\n\t\t\tstart();\n\t\t}\n\n\t\tif( scripts.length ) {\n\t\t\thead.ready( proceed );\n\n\t\t\t// Load synchronous scripts\n\t\t\thead.js.apply( null, scripts );\n\t\t}\n\t\telse {\n\t\t\tproceed();\n\t\t}\n\t}\n\n\t/**\n\t * Starts up reveal.js by binding input events and navigating \n\t * to the current URL deeplink if there is one.\n\t */\n\tfunction start() {\n\t\t// Subscribe to input\n\t\taddEventListeners();\n\n\t\t// Updates the presentation to match the current configuration values\n\t\tconfigure();\n\n\t\t// Read the initial hash\n\t\treadURL();\n\n\t\t// Start auto-sliding if it's enabled\n\t\tcueAutoSlide();\n\t}\n\n\t/**\n\t * Applies the configuration settings from the config object.\n\t */\n\tfunction configure() {\n\t\tif( supports3DTransforms === false ) {\n\t\t\tconfig.transition = 'linear';\n\t\t}\n\n\t\tif( config.controls && dom.controls ) {\n\t\t\tdom.controls.style.display = 'block';\n\t\t}\n\n\t\tif( config.progress && dom.progress ) {\n\t\t\tdom.progress.style.display = 'block';\n\t\t}\n\n\t\t// Load the theme in the config, if it's not already loaded\n\t\tif( config.theme && dom.theme ) {\n\t\t\tvar themeURL = dom.theme.getAttribute( 'href' );\n\t\t\tvar themeFinder = /[^\\/]*?(?=\\.css)/;\n\t\t\tvar themeName = themeURL.match(themeFinder)[0];\n\n\t\t\tif(  config.theme !== themeName ) {\n\t\t\t\tthemeURL = themeURL.replace(themeFinder, config.theme);\n\t\t\t\tdom.theme.setAttribute( 'href', themeURL );\n\t\t\t}\n\t\t}\n\n\t\tif( config.transition !== 'default' ) {\n\t\t\tdom.wrapper.classList.add( config.transition );\n\t\t}\n\n\t\tif( config.mouseWheel ) {\n\t\t\tdocument.addEventListener( 'DOMMouseScroll', onDocumentMouseScroll, false ); // FF\n\t\t\tdocument.addEventListener( 'mousewheel', onDocumentMouseScroll, false );\n\t\t}\n\n\t\tif( config.rollingLinks ) {\n\t\t\t// Add some 3D magic to our anchors\n\t\t\tlinkify();\n\t\t}\n\t}\n\n\tfunction addEventListeners() {\n\t\tdocument.addEventListener( 'touchstart', onDocumentTouchStart, false );\n\t\tdocument.addEventListener( 'touchmove', onDocumentTouchMove, false );\n\t\tdocument.addEventListener( 'touchend', onDocumentTouchEnd, false );\n\t\twindow.addEventListener( 'hashchange', onWindowHashChange, false );\n\n\t\tif( config.keyboard ) {\n\t\t\tdocument.addEventListener( 'keydown', onDocumentKeyDown, false );\n\t\t}\n\n\t\tif ( config.controls && dom.controls ) {\n\t\t\tdom.controlsLeft.addEventListener( 'click', preventAndForward( navigateLeft ), false );\n\t\t\tdom.controlsRight.addEventListener( 'click', preventAndForward( navigateRight ), false );\n\t\t\tdom.controlsUp.addEventListener( 'click', preventAndForward( navigateUp ), false );\n\t\t\tdom.controlsDown.addEventListener( 'click', preventAndForward( navigateDown ), false );\t\n\t\t}\n\t}\n\n\tfunction removeEventListeners() {\n\t\tdocument.removeEventListener( 'keydown', onDocumentKeyDown, false );\n\t\tdocument.removeEventListener( 'touchstart', onDocumentTouchStart, false );\n\t\tdocument.removeEventListener( 'touchmove', onDocumentTouchMove, false );\n\t\tdocument.removeEventListener( 'touchend', onDocumentTouchEnd, false );\n\t\twindow.removeEventListener( 'hashchange', onWindowHashChange, false );\n\t\t\n\t\tif ( config.controls && dom.controls ) {\n\t\t\tdom.controlsLeft.removeEventListener( 'click', preventAndForward( navigateLeft ), false );\n\t\t\tdom.controlsRight.removeEventListener( 'click', preventAndForward( navigateRight ), false );\n\t\t\tdom.controlsUp.removeEventListener( 'click', preventAndForward( navigateUp ), false );\n\t\t\tdom.controlsDown.removeEventListener( 'click', preventAndForward( navigateDown ), false );\n\t\t}\n\t}\n\n\t/**\n\t * Extend object a with the properties of object b. \n\t * If there's a conflict, object b takes precedence.\n\t */\n\tfunction extend( a, b ) {\n\t\tfor( var i in b ) {\n\t\t\ta[ i ] = b[ i ];\n\t\t}\n\t}\n\n\t/**\n\t * Measures the distance in pixels between point a\n\t * and point b. \n\t * \n\t * @param {Object} a point with x/y properties\n\t * @param {Object} b point with x/y properties\n\t */\n\tfunction distanceBetween( a, b ) {\n\t\tvar dx = a.x - b.x,\n\t\t\tdy = a.y - b.y;\n\n\t\treturn Math.sqrt( dx*dx + dy*dy );\n\t}\n\n\t/**\n\t * Prevents an events defaults behavior calls the \n\t * specified delegate.\n\t * \n\t * @param {Function} delegate The method to call \n\t * after the wrapper has been executed\n\t */\n\tfunction preventAndForward( delegate ) {\n\t\treturn function( event ) {\n\t\t\tevent.preventDefault();\n\t\t\tdelegate.call();\n\t\t};\n\t}\n\n\t/**\n\t * Causes the address bar to hide on mobile devices, \n\t * more vertical space ftw.\n\t */\n\tfunction removeAddressBar() {\n\t\tsetTimeout( function() {\n\t\t\twindow.scrollTo( 0, 1 );\n\t\t}, 0 );\n\t}\n\n\t/**\n\t * Dispatches an event of the specified type from the \n\t * reveal DOM element.\n\t */\n\tfunction dispatchEvent( type, properties ) {\n\t\tvar event = document.createEvent( \"HTMLEvents\", 1, 2 );\n\t\tevent.initEvent( type, true, true );\n\t\textend( event, properties );\n\t\tdom.wrapper.dispatchEvent( event );\n\t}\n\t\n\t/**\n\t * Handler for the document level 'keydown' event.\n\t * \n\t * @param {Object} event\n\t */\n\tfunction onDocumentKeyDown( event ) {\n\t\t// Disregard the event if the target is editable or a \n\t\t// modifier is present\n\t\tif ( document.querySelector( ':focus' ) !== null || event.shiftKey || event.altKey || event.ctrlKey || event.metaKey ) return;\n\n\t\tvar triggered = true;\n\n\t\tswitch( event.keyCode ) {\n\t\t\t// p, page up\n\t\t\tcase 80: case 33: navigatePrev(); break; \n\t\t\t// n, page down\n\t\t\tcase 78: case 34: navigateNext(); break;\n\t\t\t// h, left\n\t\t\tcase 72: case 37: navigateLeft(); break;\n\t\t\t// l, right\n\t\t\tcase 76: case 39: navigateRight(); break;\n\t\t\t// k, up\n\t\t\tcase 75: case 38: navigateUp(); break;\n\t\t\t// j, down\n\t\t\tcase 74: case 40: navigateDown(); break;\n\t\t\t// home\n\t\t\tcase 36: navigateTo( 0 ); break;\n\t\t\t// end\n\t\t\tcase 35: navigateTo( Number.MAX_VALUE ); break;\n\t\t\t// space\n\t\t\tcase 32: isOverviewActive() ? deactivateOverview() : navigateNext(); break;\n\t\t\t// return\n\t\t\tcase 13: isOverviewActive() ? deactivateOverview() : triggered = false; break;\n\t\t\t// b, period\n\t\t\tcase 66: case 190: togglePause(); break;\n\t\t\tdefault:\n\t\t\t\ttriggered = false;\n\t\t}\n\n\t\t// If the input resulted in a triggered action we should prevent \n\t\t// the browsers default behavior\n\t\tif( triggered ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t\telse if ( event.keyCode === 27 && supports3DTransforms ) {\n\t\t\ttoggleOverview();\n\t\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// If auto-sliding is enabled we need to cue up \n\t\t// another timeout\n\t\tcueAutoSlide();\n\n\t}\n\n\t/**\n\t * Handler for the document level 'touchstart' event,\n\t * enables support for swipe and pinch gestures.\n\t */\n\tfunction onDocumentTouchStart( event ) {\n\t\ttouch.startX = event.touches[0].clientX;\n\t\ttouch.startY = event.touches[0].clientY;\n\t\ttouch.startCount = event.touches.length;\n\n\t\t// If there's two touches we need to memorize the distance \n\t\t// between those two points to detect pinching\n\t\tif( event.touches.length === 2 ) {\n\t\t\ttouch.startSpan = distanceBetween( {\n\t\t\t\tx: event.touches[1].clientX,\n\t\t\t\ty: event.touches[1].clientY\n\t\t\t}, {\n\t\t\t\tx: touch.startX,\n\t\t\t\ty: touch.startY\n\t\t\t} );\n\t\t}\n\t}\n\t\n\t/**\n\t * Handler for the document level 'touchmove' event.\n\t */\n\tfunction onDocumentTouchMove( event ) {\n\t\t// Each touch should only trigger one action\n\t\tif( !touch.handled ) {\n\t\t\tvar currentX = event.touches[0].clientX;\n\t\t\tvar currentY = event.touches[0].clientY;\n\n\t\t\t// If the touch started off with two points and still has \n\t\t\t// two active touches; test for the pinch gesture\n\t\t\tif( event.touches.length === 2 && touch.startCount === 2 ) {\n\n\t\t\t\t// The current distance in pixels between the two touch points\n\t\t\t\tvar currentSpan = distanceBetween( {\n\t\t\t\t\tx: event.touches[1].clientX,\n\t\t\t\t\ty: event.touches[1].clientY\n\t\t\t\t}, {\n\t\t\t\t\tx: touch.startX,\n\t\t\t\t\ty: touch.startY\n\t\t\t\t} );\n\n\t\t\t\t// If the span is larger than the desire amount we've got \n\t\t\t\t// ourselves a pinch\n\t\t\t\tif( Math.abs( touch.startSpan - currentSpan ) > touch.threshold ) {\n\t\t\t\t\ttouch.handled = true;\n\n\t\t\t\t\tif( currentSpan < touch.startSpan ) {\n\t\t\t\t\t\tactivateOverview();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdeactivateOverview();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// There was only one touch point, look for a swipe\n\t\t\telse if( event.touches.length === 1 ) {\n\t\t\t\tvar deltaX = currentX - touch.startX,\n\t\t\t\t\tdeltaY = currentY - touch.startY;\n\n\t\t\t\tif( deltaX > touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {\n\t\t\t\t\ttouch.handled = true;\n\t\t\t\t\tnavigateLeft();\n\t\t\t\t} \n\t\t\t\telse if( deltaX < -touch.threshold && Math.abs( deltaX ) > Math.abs( deltaY ) ) {\n\t\t\t\t\ttouch.handled = true;\n\t\t\t\t\tnavigateRight();\n\t\t\t\t} \n\t\t\t\telse if( deltaY > touch.threshold ) {\n\t\t\t\t\ttouch.handled = true;\n\t\t\t\t\tnavigateUp();\n\t\t\t\t} \n\t\t\t\telse if( deltaY < -touch.threshold ) {\n\t\t\t\t\ttouch.handled = true;\n\t\t\t\t\tnavigateDown();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\t\t}\n\t\t// There's a bug with swiping on some Android devices unless \n\t\t// the default action is always prevented\n\t\telse if( navigator.userAgent.match( /android/gi ) ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n\n\t/**\n\t * Handler for the document level 'touchend' event.\n\t */\n\tfunction onDocumentTouchEnd( event ) {\n\t\ttouch.handled = false;\n\t}\n\n\t/**\n\t * Handles mouse wheel scrolling, throttled to avoid \n\t * skipping multiple slides.\n\t */\n\tfunction onDocumentMouseScroll( event ){\n\t\tclearTimeout( mouseWheelTimeout );\n\n\t\tmouseWheelTimeout = setTimeout( function() {\n\t\t\tvar delta = event.detail || -event.wheelDelta;\n\t\t\tif( delta > 0 ) {\n\t\t\t\tnavigateNext();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnavigatePrev();\n\t\t\t}\n\t\t}, 100 );\n\t}\n\t\n\t/**\n\t * Handler for the window level 'hashchange' event.\n\t * \n\t * @param {Object} event\n\t */\n\tfunction onWindowHashChange( event ) {\n\t\treadURL();\n\t}\n\n\t/**\n\t * Invoked when a slide is and we're in the overview.\n\t */\n\tfunction onOverviewSlideClicked( event ) {\n\t\t// TODO There's a bug here where the event listeners are not \n\t\t// removed after deactivating the overview.\n\t\tif( isOverviewActive() ) {\n\t\t\tevent.preventDefault();\n\n\t\t\tdeactivateOverview();\n\n\t\t\tindexh = this.getAttribute( 'data-index-h' );\n\t\t\tindexv = this.getAttribute( 'data-index-v' );\n\n\t\t\tslide();\n\t\t}\n\t}\n\n\t/**\n\t * Wrap all links in 3D goodness.\n\t */\n\tfunction linkify() {\n\t\tif( supports3DTransforms && !( 'msPerspective' in document.body.style ) ) {\n\t\t\tvar nodes = document.querySelectorAll( '.reveal .slides section a:not(.image)' );\n\n\t\t\tfor( var i = 0, len = nodes.length; i < len; i++ ) {\n\t\t\t\tvar node = nodes[i];\n\t\t\t\t\n\t\t\t\tif( node.textContent && !node.querySelector( 'img' ) && ( !node.className || !node.classList.contains( node, 'roll' ) ) ) {\n\t\t\t\t\tnode.classList.add( 'roll' );\n\t\t\t\t\tnode.innerHTML = '<span data-title=\"'+ node.text +'\">' + node.innerHTML + '</span>';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Displays the overview of slides (quick nav) by \n\t * scaling down and arranging all slide elements.\n\t * \n\t * Experimental feature, might be dropped if perf \n\t * can't be improved.\n\t */\n\tfunction activateOverview() {\n\n\t\t// Only proceed if enabled in config\n\t\tif( config.overview ) {\n\t\t\n\t\t\tdom.wrapper.classList.add( 'overview' );\n\n\t\t\tvar horizontalSlides = document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );\n\n\t\t\tfor( var i = 0, len1 = horizontalSlides.length; i < len1; i++ ) {\n\t\t\t\tvar hslide = horizontalSlides[i],\n\t\t\t\t\thtransform = 'translateZ(-2500px) translate(' + ( ( i - indexh ) * 105 ) + '%, 0%)';\n\t\t\t\t\n\t\t\t\thslide.setAttribute( 'data-index-h', i );\n\t\t\t\thslide.style.display = 'block';\n\t\t\t\thslide.style.WebkitTransform = htransform;\n\t\t\t\thslide.style.MozTransform = htransform;\n\t\t\t\thslide.style.msTransform = htransform;\n\t\t\t\thslide.style.OTransform = htransform;\n\t\t\t\thslide.style.transform = htransform;\n\t\t\t\n\t\t\t\tif( !hslide.classList.contains( 'stack' ) ) {\n\t\t\t\t\t// Navigate to this slide on click\n\t\t\t\t\thslide.addEventListener( 'click', onOverviewSlideClicked, true );\n\t\t\t\t}\n\t\t\n\t\t\t\tvar verticalSlides = hslide.querySelectorAll( 'section' );\n\n\t\t\t\tfor( var j = 0, len2 = verticalSlides.length; j < len2; j++ ) {\n\t\t\t\t\tvar vslide = verticalSlides[j],\n\t\t\t\t\t\tvtransform = 'translate(0%, ' + ( ( j - ( i === indexh ? indexv : 0 ) ) * 105 ) + '%)';\n\n\t\t\t\t\tvslide.setAttribute( 'data-index-h', i );\n\t\t\t\t\tvslide.setAttribute( 'data-index-v', j );\n\t\t\t\t\tvslide.style.display = 'block';\n\t\t\t\t\tvslide.style.WebkitTransform = vtransform;\n\t\t\t\t\tvslide.style.MozTransform = vtransform;\n\t\t\t\t\tvslide.style.msTransform = vtransform;\n\t\t\t\t\tvslide.style.OTransform = vtransform;\n\t\t\t\t\tvslide.style.transform = vtransform;\n\n\t\t\t\t\t// Navigate to this slide on click\n\t\t\t\t\tvslide.addEventListener( 'click', onOverviewSlideClicked, true );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Exits the slide overview and enters the currently\n\t * active slide.\n\t */\n\tfunction deactivateOverview() {\n\t\t\n\t\t// Only proceed if enabled in config\n\t\tif( config.overview ) {\n\n\t\t\tdom.wrapper.classList.remove( 'overview' );\n\n\t\t\t// Select all slides\n\t\t\tvar slides = Array.prototype.slice.call( document.querySelectorAll( '.reveal .slides section' ) );\n\n\t\t\tfor( var i = 0, len = slides.length; i < len; i++ ) {\n\t\t\t\tvar element = slides[i];\n\n\t\t\t\t// Resets all transforms to use the external styles\n\t\t\t\telement.style.WebkitTransform = '';\n\t\t\t\telement.style.MozTransform = '';\n\t\t\t\telement.style.msTransform = '';\n\t\t\t\telement.style.OTransform = '';\n\t\t\t\telement.style.transform = '';\n\n\t\t\t\telement.removeEventListener( 'click', onOverviewSlideClicked );\n\t\t\t}\n\n\t\t\tslide();\n\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Toggles the slide overview mode on and off.\n\t *\n\t * @param {Boolean} override Optional flag which overrides the \n\t * toggle logic and forcibly sets the desired state. True means \n\t * overview is open, false means it's closed.\n\t */\n\tfunction toggleOverview( override ) {\n\t\tif( typeof override === 'boolean' ) {\n\t\t\toverride ? activateOverview() : deactivateOverview();\n\t\t}\n\t\telse {\n\t\t\tisOverviewActive() ? deactivateOverview() : activateOverview();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the overview is currently active.\n\t * \n\t * @return {Boolean} true if the overview is active,\n\t * false otherwise\n\t */\n\tfunction isOverviewActive() {\n\t\treturn dom.wrapper.classList.contains( 'overview' );\n\t}\n\n\t/**\n\t * Enters the paused mode which fades everything on screen to \n\t * black.\n\t */\n\tfunction pause() {\n\t\tdom.wrapper.classList.add( 'paused' );\n\t}\n\n\t/**\n\t * Exits from the paused mode.\n\t */\n\tfunction resume() {\n\t\tdom.wrapper.classList.remove( 'paused' );\n\t}\n\n\t/**\n\t * Toggles the paused mode on and off.\n\t */\n\tfunction togglePause() {\n\t\tif( isPaused() ) {\n\t\t\tresume();\n\t\t}\n\t\telse {\n\t\t\tpause();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if we are currently in the paused mode.\n\t */\n\tfunction isPaused() {\n\t\treturn dom.wrapper.classList.contains( 'paused' );\n\t}\n\n\t/**\n\t * Updates one dimension of slides by showing the slide\n\t * with the specified index.\n\t * \n\t * @param {String} selector A CSS selector that will fetch\n\t * the group of slides we are working with\n\t * @param {Number} index The index of the slide that should be\n\t * shown\n\t * \n\t * @return {Number} The index of the slide that is now shown,\n\t * might differ from the passed in index if it was out of \n\t * bounds.\n\t */\n\tfunction updateSlides( selector, index ) {\n\t\t\n\t\t// Select all slides and convert the NodeList result to\n\t\t// an array\n\t\tvar slides = Array.prototype.slice.call( document.querySelectorAll( selector ) ),\n\t\t\tslidesLength = slides.length;\n\t\t\n\t\tif( slidesLength ) {\n\n\t\t\t// Should the index loop?\n\t\t\tif( config.loop ) {\n\t\t\t\tindex %= slidesLength;\n\n\t\t\t\tif( index < 0 ) {\n\t\t\t\t\tindex = slidesLength + index;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Enforce max and minimum index bounds\n\t\t\tindex = Math.max( Math.min( index, slidesLength - 1 ), 0 );\n\t\t\t\n\t\t\tfor( var i = 0; i < slidesLength; i++ ) {\n\t\t\t\tvar slide = slides[i];\n\n\t\t\t\t// Optimization; hide all slides that are three or more steps \n\t\t\t\t// away from the present slide\n\t\t\t\tif( isOverviewActive() === false ) {\n\t\t\t\t\t// The distance loops so that it measures 1 between the first\n\t\t\t\t\t// and last slides\n\t\t\t\t\tvar distance = Math.abs( ( index - i ) % ( slidesLength - 3 ) ) || 0;\n\n\t\t\t\t\tslide.style.display = distance > 3 ? 'none' : 'block';\n\t\t\t\t}\n\n\t\t\t\tslides[i].classList.remove( 'past' );\n\t\t\t\tslides[i].classList.remove( 'present' );\n\t\t\t\tslides[i].classList.remove( 'future' );\n\n\t\t\t\tif( i < index ) {\n\t\t\t\t\t// Any element previous to index is given the 'past' class\n\t\t\t\t\tslides[i].classList.add( 'past' );\n\t\t\t\t}\n\t\t\t\telse if( i > index ) {\n\t\t\t\t\t// Any element subsequent to index is given the 'future' class\n\t\t\t\t\tslides[i].classList.add( 'future' );\n\t\t\t\t}\n\n\t\t\t\t// If this element contains vertical slides\n\t\t\t\tif( slide.querySelector( 'section' ) ) {\n\t\t\t\t\tslides[i].classList.add( 'stack' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mark the current slide as present\n\t\t\tslides[index].classList.add( 'present' );\n\n\t\t\t// If this slide has a state associated with it, add it\n\t\t\t// onto the current state of the deck\n\t\t\tvar slideState = slides[index].getAttribute( 'data-state' );\n\t\t\tif( slideState ) {\n\t\t\t\tstate = state.concat( slideState.split( ' ' ) );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Since there are no slides we can't be anywhere beyond the \n\t\t\t// zeroth index\n\t\t\tindex = 0;\n\t\t}\n\t\t\n\t\treturn index;\n\t\t\n\t}\n\t\n\t/**\n\t * Steps from the current point in the presentation to the \n\t * slide which matches the specified horizontal and vertical \n\t * indices. \n\t *\n\t * @param {int} h Horizontal index of the target slide\n\t * @param {int} v Vertical index of the target slide\n\t */\n\tfunction slide( h, v ) {\n\t\t// Remember where we were at before\n\t\tpreviousSlide = currentSlide;\n\n\t\t// Remember the state before this slide\n\t\tvar stateBefore = state.concat();\n\n\t\t// Reset the state array\n\t\tstate.length = 0;\n\n\t\tvar indexhBefore = indexh,\n\t\t\tindexvBefore = indexv;\n\n\t\t// Activate and transition to the new slide\n\t\tindexh = updateSlides( HORIZONTAL_SLIDES_SELECTOR, h === undefined ? indexh : h );\n\t\tindexv = updateSlides( VERTICAL_SLIDES_SELECTOR, v === undefined ? indexv : v );\n\n\t\t// Apply the new state\n\t\tstateLoop: for( var i = 0, len = state.length; i < len; i++ ) {\n\t\t\t// Check if this state existed on the previous slide. If it \n\t\t\t// did, we will avoid adding it repeatedly.\n\t\t\tfor( var j = 0; j < stateBefore.length; j++ ) {\n\t\t\t\tif( stateBefore[j] === state[i] ) {\n\t\t\t\t\tstateBefore.splice( j, 1 );\n\t\t\t\t\tcontinue stateLoop;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.documentElement.classList.add( state[i] );\n\n\t\t\t// Dispatch custom event matching the state's name\n\t\t\tdispatchEvent( state[i] );\n\t\t}\n\n\t\t// Clean up the remaints of the previous state\n\t\twhile( stateBefore.length ) {\n\t\t\tdocument.documentElement.classList.remove( stateBefore.pop() );\n\t\t}\n\n\t\t// Update progress if enabled\n\t\tif( config.progress && dom.progress ) {\n\t\t\tdom.progressbar.style.width = ( indexh / ( document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ).length - 1 ) ) * window.innerWidth + 'px';\n\t\t}\n\n\t\t// If the overview is active, re-activate it to update positions\n\t\tif( isOverviewActive() ) {\n\t\t\tactivateOverview();\n\t\t}\n\n\t\tupdateControls();\n\t\t\n\t\tclearTimeout( writeURLTimeout );\n\t\twriteURLTimeout = setTimeout( writeURL, 1500 );\n\n\t\t// Query all horizontal slides in the deck\n\t\tvar horizontalSlides = document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR );\n\n\t\t// Find the current horizontal slide and any possible vertical slides\n\t\t// within it\n\t\tvar currentHorizontalSlide = horizontalSlides[ indexh ],\n\t\t\tcurrentVerticalSlides = currentHorizontalSlide.querySelectorAll( 'section' );\n\n\t\t// Store references to the previous and current slides\n\t\tcurrentSlide = currentVerticalSlides[ indexv ] || currentHorizontalSlide;\n\n\t\t// Dispatch an event if the slide changed\n\t\tif( indexh !== indexhBefore || indexv !== indexvBefore ) {\n\t\t\tdispatchEvent( 'slidechanged', {\n\t\t\t\t'indexh': indexh, \n\t\t\t\t'indexv': indexv,\n\t\t\t\t'previousSlide': previousSlide,\n\t\t\t\t'currentSlide': currentSlide\n\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// Ensure that the previous slide is never the same as the current\n\t\t\tpreviousSlide = null;\n\t\t}\n\n\t\t// Solves an edge case where the previous slide maintains the \n\t\t// 'present' class when navigating between adjacent vertical \n\t\t// stacks\n\t\tif( previousSlide ) {\n\t\t\tpreviousSlide.classList.remove( 'present' );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the state and link pointers of the controls.\n\t */\n\tfunction updateControls() {\n\t\tif ( !config.controls || !dom.controls ) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar routes = availableRoutes();\n\n\t\t// Remove the 'enabled' class from all directions\n\t\t[ dom.controlsLeft, dom.controlsRight, dom.controlsUp, dom.controlsDown ].forEach( function( node ) {\n\t\t\tnode.classList.remove( 'enabled' );\n\t\t} );\n\n\t\t// Add the 'enabled' class to the available routes\n\t\tif( routes.left ) dom.controlsLeft.classList.add( 'enabled' );\n\t\tif( routes.right ) dom.controlsRight.classList.add( 'enabled' );\n\t\tif( routes.up ) dom.controlsUp.classList.add( 'enabled' );\n\t\tif( routes.down ) dom.controlsDown.classList.add( 'enabled' );\n\t}\n\n\t/**\n\t * Determine what available routes there are for navigation.\n\t * \n\t * @return {Object} containing four booleans: left/right/up/down\n\t */\n\tfunction availableRoutes() {\n\t\tvar horizontalSlides = document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ),\n\t\t\tverticalSlides = document.querySelectorAll( VERTICAL_SLIDES_SELECTOR );\n\n\t\treturn {\n\t\t\tleft: indexh > 0,\n\t\t\tright: indexh < horizontalSlides.length - 1,\n\t\t\tup: indexv > 0,\n\t\t\tdown: indexv < verticalSlides.length - 1\n\t\t};\n\t}\n\t\n\t/**\n\t * Reads the current URL (hash) and navigates accordingly.\n\t */\n\tfunction readURL() {\n\t\tvar hash = window.location.hash;\n\n\t\t// Attempt to parse the hash as either an index or name\n\t\tvar bits = hash.slice( 2 ).split( '/' ),\n\t\t\tname = hash.replace( /#|\\//gi, '' );\n\n\t\t// If the first bit is invalid and there is a name we can \n\t\t// assume that this is a named link\n\t\tif( isNaN( parseInt( bits[0], 10 ) ) && name.length ) {\n\t\t\t// Find the slide with the specified name\n\t\t\tvar slide = document.querySelector( '#' + name );\n\n\t\t\tif( slide ) {\n\t\t\t\t// Find the position of the named slide and navigate to it\n\t\t\t\tvar indices = Reveal.getIndices( slide );\n\t\t\t\tnavigateTo( indices.h, indices.v );\n\t\t\t}\n\t\t\t// If the slide doesn't exist, navigate to the current slide\n\t\t\telse {\n\t\t\t\tnavigateTo( indexh, indexv );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Read the index components of the hash\n\t\t\tvar h = parseInt( bits[0], 10 ) || 0,\n\t\t\t\tv = parseInt( bits[1], 10 ) || 0;\n\n\t\t\tnavigateTo( h, v );\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates the page URL (hash) to reflect the current\n\t * state. \n\t */\n\tfunction writeURL() {\n\t\tif( config.history ) {\n\t\t\tvar url = '/';\n\t\t\t\n\t\t\t// Only include the minimum possible number of components in\n\t\t\t// the URL\n\t\t\tif( indexh > 0 || indexv > 0 ) url += indexh;\n\t\t\tif( indexv > 0 ) url += '/' + indexv;\n\t\t\t\n\t\t\twindow.location.hash = url;\n\t\t}\n\t}\n\n\t/**\n\t * Navigate to the next slide fragment.\n\t * \n\t * @return {Boolean} true if there was a next fragment,\n\t * false otherwise\n\t */\n\tfunction nextFragment() {\n\t\t// Vertical slides:\n\t\tif( document.querySelector( VERTICAL_SLIDES_SELECTOR + '.present' ) ) {\n\t\t\tvar verticalFragments = document.querySelectorAll( VERTICAL_SLIDES_SELECTOR + '.present .fragment:not(.visible)' );\n\t\t\tif( verticalFragments.length ) {\n\t\t\t\tverticalFragments[0].classList.add( 'visible' );\n\n\t\t\t\t// Notify subscribers of the change\n\t\t\t\tdispatchEvent( 'fragmentshown', { fragment: verticalFragments[0] } );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Horizontal slides:\n\t\telse {\n\t\t\tvar horizontalFragments = document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.present .fragment:not(.visible)' );\n\t\t\tif( horizontalFragments.length ) {\n\t\t\t\thorizontalFragments[0].classList.add( 'visible' );\n\n\t\t\t\t// Notify subscribers of the change\n\t\t\t\tdispatchEvent( 'fragmentshown', { fragment: horizontalFragments[0] } );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Navigate to the previous slide fragment.\n\t * \n\t * @return {Boolean} true if there was a previous fragment,\n\t * false otherwise\n\t */\n\tfunction previousFragment() {\n\t\t// Vertical slides:\n\t\tif( document.querySelector( VERTICAL_SLIDES_SELECTOR + '.present' ) ) {\n\t\t\tvar verticalFragments = document.querySelectorAll( VERTICAL_SLIDES_SELECTOR + '.present .fragment.visible' );\n\t\t\tif( verticalFragments.length ) {\n\t\t\t\tverticalFragments[ verticalFragments.length - 1 ].classList.remove( 'visible' );\n\n\t\t\t\t// Notify subscribers of the change\n\t\t\t\tdispatchEvent( 'fragmenthidden', { fragment: verticalFragments[ verticalFragments.length - 1 ] } );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// Horizontal slides:\n\t\telse {\n\t\t\tvar horizontalFragments = document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR + '.present .fragment.visible' );\n\t\t\tif( horizontalFragments.length ) {\n\t\t\t\thorizontalFragments[ horizontalFragments.length - 1 ].classList.remove( 'visible' );\n\n\t\t\t\t// Notify subscribers of the change\n\t\t\t\tdispatchEvent( 'fragmenthidden', { fragment: horizontalFragments[ horizontalFragments.length - 1 ] } );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\t/**\n\t * Cues a new automated slide if enabled in the config.\n\t */\n\tfunction cueAutoSlide() {\n\t\tclearTimeout( autoSlideTimeout );\n\n\t\t// Cue the next auto-slide if enabled\n\t\tif( config.autoSlide ) {\n\t\t\tautoSlideTimeout = setTimeout( navigateNext, config.autoSlide );\n\t\t}\n\t}\n\t\n\t/**\n\t * Triggers a navigation to the specified indices.\n\t * \n\t * @param {Number} h The horizontal index of the slide to show\n\t * @param {Number} v The vertical index of the slide to show\n\t */\n\tfunction navigateTo( h, v ) {\n\t\tslide( h, v );\n\t}\n\t\n\tfunction navigateLeft() {\n\t\t// Prioritize hiding fragments\n\t\tif( isOverviewActive() || previousFragment() === false ) {\n\t\t\tslide( indexh - 1, 0 );\n\t\t}\n\t}\n\n\tfunction navigateRight() {\n\t\t// Prioritize revealing fragments\n\t\tif( isOverviewActive() || nextFragment() === false ) {\n\t\t\tslide( indexh + 1, 0 );\n\t\t}\n\t}\n\n\tfunction navigateUp() {\n\t\t// Prioritize hiding fragments\n\t\tif( isOverviewActive() || previousFragment() === false ) {\n\t\t\tslide( indexh, indexv - 1 );\n\t\t}\n\t}\n\n\tfunction navigateDown() {\n\t\t// Prioritize revealing fragments\n\t\tif( isOverviewActive() || nextFragment() === false ) {\n\t\t\tslide( indexh, indexv + 1 );\n\t\t}\n\t}\n\n\t/**\n\t * Navigates backwards, prioritized in the following order:\n\t * 1) Previous fragment\n\t * 2) Previous vertical slide\n\t * 3) Previous horizontal slide\n\t */\n\tfunction navigatePrev() {\n\t\t// Prioritize revealing fragments\n\t\tif( previousFragment() === false ) {\n\t\t\tif( availableRoutes().up ) {\n\t\t\t\tnavigateUp();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Fetch the previous horizontal slide, if there is one\n\t\t\t\tvar previousSlide = document.querySelector( '.reveal .slides>section.past:nth-child(' + indexh + ')' );\n\n\t\t\t\tif( previousSlide ) {\n\t\t\t\t\tindexv = ( previousSlide.querySelectorAll('section').length + 1 ) || 0;\n\t\t\t\t\tindexh --;\n\t\t\t\t\tslide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Same as #navigatePrev() but navigates forwards.\n\t */\n\tfunction navigateNext() {\n\t\t// Prioritize revealing fragments\n\t\tif( nextFragment() === false ) {\n\t\t\tavailableRoutes().down ? navigateDown() : navigateRight();\n\t\t}\n\n\t\t// If auto-sliding is enabled we need to cue up \n\t\t// another timeout\n\t\tcueAutoSlide();\n\t}\n\t\n\t// Expose some methods publicly\n\treturn {\n\t\tinitialize: initialize,\n\t\tnavigateTo: navigateTo,\n\t\tnavigateLeft: navigateLeft,\n\t\tnavigateRight: navigateRight,\n\t\tnavigateUp: navigateUp,\n\t\tnavigateDown: navigateDown,\n\t\tnavigatePrev: navigatePrev,\n\t\tnavigateNext: navigateNext,\n\t\ttoggleOverview: toggleOverview,\n\n\t\t// Adds or removes all internal event listeners (such as keyboard)\n\t\taddEventListeners: addEventListeners,\n\t\tremoveEventListeners: removeEventListeners,\n\n\t\t// Returns the indices of the current, or specified, slide\n\t\tgetIndices: function( slide ) {\n\t\t\t// By default, return the current indices\n\t\t\tvar h = indexh,\n\t\t\t\tv = indexv;\n\n\t\t\t// If a slide is specified, return the indices of that slide\n\t\t\tif( slide ) {\n\t\t\t\tvar isVertical = !!slide.parentNode.nodeName.match( /section/gi );\n\t\t\t\tvar slideh = isVertical ? slide.parentNode : slide;\n\n\t\t\t\t// Select all horizontal slides\n\t\t\t\tvar horizontalSlides = Array.prototype.slice.call( document.querySelectorAll( HORIZONTAL_SLIDES_SELECTOR ) );\n\n\t\t\t\t// Now that we know which the horizontal slide is, get its index\n\t\t\t\th = Math.max( horizontalSlides.indexOf( slideh ), 0 );\n\n\t\t\t\t// If this is a vertical slide, grab the vertical index\n\t\t\t\tif( isVertical ) {\n\t\t\t\t\tv = Math.max( Array.prototype.slice.call( slide.parentNode.children ).indexOf( slide ), 0 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn { h: h, v: v };\n\t\t},\n\n\t\t// Returns the previous slide element, may be null\n\t\tgetPreviousSlide: function() {\n\t\t\treturn previousSlide;\n\t\t},\n\n\t\t// Returns the current slide element\n\t\tgetCurrentSlide: function() {\n\t\t\treturn currentSlide;\n\t\t},\n\n\t\t// Helper method, retrieves query string as a key/value hash\n\t\tgetQueryHash: function() {\n\t\t\tvar query = {};\n\n\t\t\tlocation.search.replace( /[A-Z0-9]+?=(\\w*)/gi, function(a) {\n\t\t\t\tquery[ a.split( '=' ).shift() ] = a.split( '=' ).pop();\n\t\t\t} );\n\n\t\t\treturn query;\n\t\t},\n\n\t\t// Forward event binding to the reveal DOM element\n\t\taddEventListener: function( type, listener, useCapture ) {\n\t\t\tif( 'addEventListener' in window ) {\n\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).addEventListener( type, listener, useCapture );\n\t\t\t}\n\t\t},\n\t\tremoveEventListener: function( type, listener, useCapture ) {\n\t\t\tif( 'addEventListener' in window ) {\n\t\t\t\t( dom.wrapper || document.querySelector( '.reveal' ) ).removeEventListener( type, listener, useCapture );\n\t\t\t}\n\t\t}\n\t};\n\t\n})();"]],"start1":0,"start2":0,"length1":0,"length2":35793}]],"length":35793,"saved":false}
